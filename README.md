## 介绍

GoF 23种经典设计模式，C++实现。

## 分类

### 创建型

- 单例模式（Singleton）  
  确保一个类只有一个实例，并提供一个全局访问点。

- 简单工厂模式（SimpleFactory）  
  这是一种简单的实现，用一个静态方法来创建所有对象。它不属于23种经典设计模式，但非常常用。

- 工厂方法模式（FactoryMethod）  
  在父类中提供一个创建对象的接口，以允许子类决定实例化对象的类型。

- 抽象工厂模式（AbstractFactory）  
  创建一族相关的对象，且无需指定具体类。

- 生成器模式（Builder）  
  分步骤创建复杂对象。

- 原型模式（Prototype）  
  通过克隆已有对象快速创建新对象，避免重复构建。

### 结构型

- 享元模式（Flyweight）  
  共享相似对象，减少内存使用，提高性能。

- 组合模式（Composite）  
  将对象组合成树形结构，使用户对单个对象和组合对象使用一致方式。

- 代理模式（Proxy）  
  用一个对象代表另一个对象，控制访问权限或延迟加载等。

- 装饰器模式（Decorator）  
  动态地给对象添加额外职责，不修改其结构。

- 外观模式（Facade）  
  为复杂系统提供一个统一入口，简化使用。

- 适配器模式（Adapter）  
  将一个类的接口转换成客户端期望的另一个接口。  
  分为类适配器和对象适配器两种。

- 桥接模式（Bridge）  
  将抽象与实现分离，使它们可以独立变化。

### 行为型

- 责任链模式（ChainOfResponsibility）  
  将请求沿着处理链传递，直到有对象处理它为止。  
  常用于事件处理、请求分发、日志处理、权限验证、责任下放。Windows消息处理机制、Qt事件传递均是使用的此模式。

- 策略模式（Strategy）  
  定义一组算法，把它们封装起来，使得它们可以互换使用。

- 观察者模式（Observer）  
  一个对象状态变化时，自动通知所有依赖它的对象。

- 状态模式（State）  
  将状态封装成独立类，使对象行为随状态变化而变化。

- 中介者模式（Mediator）  
  用一个中介对象封装多个对象之间的交互，降低耦合。

- 迭代器模式（Iterator）  
  提供一种方法顺序访问集合对象，而不暴露其内部表示。  
  对应C++中容器的iterator。

- 命令模式（Command）  
  将请求封装成对象，以便参数化、排队或记录请求。

- 模板方法模式（TemplateMethod）  
  定义一个算法框架，将具体步骤延迟到子类实现。

- 备忘录模式（Momento）  
  保存对象的某个状态，以便之后恢复。

- 访问者模式（Visitor）  
  对一组对象执行操作，不改变其结构，实现操作与对象分离。

- 解释器模式（Interpreter）  
  为语言创建解释器，定义语法规则并解释句子。  
  很少使用，以至于RefactoringGuru网站上都没有贴出来。

## 参考

- 书籍《设计模式-可复用面向对象软件的基础》
- ChatGPT、Gemini
- [RefactoringGuru](https://refactoringguru.cn/design-patterns)
